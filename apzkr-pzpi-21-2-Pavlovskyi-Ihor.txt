Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації роботи теплиць або домашніх мікроферм

Студент гр. ПЗПІ-21-2	__________________ Павловський. І. В.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)



Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Павловському Ігорю Вікторовичу
1.	Тема роботи: «Програмна система для автоматизації роботи теплиць або домашніх мікроферм»	
2.	Термін узгодження завдання курсової роботи « 25 » березня  2024 р.
3.	Термін здачі студентом закінченої роботи «17» червня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
Реєстрація та вхід в систему, редагування профіля користувача, перегляд/додавання/редагування/видалення інформації про теплиці, датчикі та розклади, перегляд та видалення всіх наявних повідомлень, яки прийшли з ІоТ пристрою	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз та концептуалне моделювання предметної області, постановка задачі, проектування програмної системи, розробка програмної системи, висновки, перелік джерел посилання, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML-діаграма прецедентів, ER-модель даних, UML діаграма розгортання, UML діаграма станів, Схема фізичної моделі системи	


КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	14.04.2024	виконано
2	Проектування програмного
проекту	21.05.2024	виконано
3	Кодування програмного проекту	03.06.2024	виконано
4	Оформлення пояснювальної
записки	10.06.2024	виконано
5	Захист курсової роботи	17.06.2024	виконано

Дата видачі завдання « 25 » березня  2024 р.

Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________         Павловський І. В.
(підпис)


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 89 с., 5 рис., 3 додатка, 5 джерел.
ТЕПЛИЦІ, МІКРОФЕРМИ, ДАТЧИКИ, РОЗКЛАД, КЕРУВАННЯ, АВТОМАТИЗАЦІЯ.
	Метою роботи є розробка програмної системи для оптимізації роботи теплиць та домашніх мікроферм.
Методи розробки базуються на використанні середовища розробки Microsoft Visual Studio 2022 та Microsoft Visual Studio Code, платформи .NET 8, REST API, ASP.NET CORE, .NET MAUI, мов програмування C#, C++, JavaScript та фреймворка React, а також мов розмітки HTML, XML, CSS .
В результаті отримана програмна система, яка дозволить зручно та ефективно керувати теплицями та домашніми мікрофермами.


ЗМІСТ
ВСТУП ……………………………………………………………………………….. 7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ....................................................................................................................... 8
1.1 Бізнес-вимоги ……………………………………………………………………. 8
1.1.	1 Передумови ………………………………………………………………… 8
1.1.2 Бізнес-можливості …………………………………………………………. 8
1.1.3 Бізнес-цілі та критерії успіху …………………………………………….. 10
1.1.4 Потреби клієнтів та ринку ………………………………………………... 11
1.1.5 Бізнес-ризики ……………………………………………………………… 12
1.2 Концепція рішення ……………………………………………………………... 13
1.2.1 Окреслення концепції …………………………………………………...... 13
1.2.2 Головна функціональність ……………………………………………….. 14
1.2.3 Припущення та залежності ………………………………………………. 16
1.3	 Рамки та обмеження …………………………………………………………… 17
1.3.1 Рамки первинного випуску ………………………………………………. 17
1.3.2 Рамки наступних випусків ……………………………………………….. 18
1.3.3 Обмеження та вийнятки ………………………………………………….. 20
1.4 Бізнес-контекст …………………………………………………………………  21
1.4.1 Профілі зацікавлених сторін ……………………………………………... 21
1.4.2 Пріоритети проекту ……………………………………………………….. 22
1.4.3 Робоче середовище ………………………………………………………... 23
2 ПОСТАНОВКА ЗАДАЧІ ........................................................................................ 25
3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ ................................................... 27
4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ ................................................................ 28
4.1 Загальна архітектура системи .............................................................................. 28
4.2 Розробка серверної частини ................................................................................. 28
4.2.1 Архітектура серверної частини .................................................................. 28
4.2.2 Розробка сервера .......................................................................................... 29
4.2.3 REST специфікація ...................................................................................... 30
4.3 Розробка ІоТ девайсу ............................................................................................ 32
4.3.1 Архітектура IoT девайсу .............................................................................. 32
4.3.2 Розробка системи для IoT девайсу .............................................................. 33
4.4 Розробка веб-застосунку ....................................................................................... 34
4.4.1 Архітектура веб-застосунку ........................................................................ 34
4.4.2 Розробка системи для веб-застосунку ........................................................ 34
4.5 Розробка мобільного застосунку .......................................................................... 36
4.5.1 Архітектура мобільного застосунку............................................................ 36
4.5.2 Розробка системи для мобільного застосунку ........................................... 37
ВИСНОВКИ ................................................................................................................. 39
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ ........................................................................... 40
ДОДАТОК А ................................................................................................................ 41
ДОДАТОК Б ................................................................................................................ 46
ДОДАТОК В ................................................................................................................ 58


ВСТУП


В останні роки попит на стале сільське господарство та самодостатнє виробництво продуктів харчування значно зріс. З ростом урбанізації та нагальною потребою у збереженні навколишнього середовища, інноваційні рішення для сільського господарства з контрольованим середовищем стали вкрай важливими. Цей курсовий проект представляє розробку програмної системи, призначеної для управління теплицями та домашніми мікро-фермами, використовуючи сучасні технології для оптимізації сільськогосподарської продуктивності та ефективності використання ресурсів.
Запропонована програмна система інтегрує різні датчики, виконавчі механізми та інструменти аналізу даних для моніторингу та регулювання умов навколишнього середовища в теплицях та мікрофермах. Автоматизуючи такі процеси, як контроль температури, регулювання вологості та освітлення, система має на меті створити оптимальні умови для вирощування широкого спектру культур. Це не лише підвищує врожайність та якість продукції, але й мінімізує втрати ресурсів, роблячи сільське господарство більш стійким та економічно життєздатним.
Програмна система побудована з урахуванням масштабованості та зручності для користувача, що дозволяє обслуговувати як комерційних операторів теплиць, так і міських садівників з обмеженим простором. Вона пропонує інтерфейс, що налаштовується, який дозволяє користувачам встановлювати параметри відповідно до конкретних вимог культур і умов навколишнього середовища. Крім того, система підтримує віддалений моніторинг і управління за допомогою мобільного додатку, надаючи користувачам оновлення в режимі реального часу і гнучкість в управлінні своїми фермами з будь-якого місця.


1 	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 	Бізнес-вимоги

1.1.1	 Передумови


Власники теплиць і домашніх мікроферм стикаються з певними проблемами у досягненні оптимального здоров'я рослин і врожайності. До них відносяться труднощі з підтриманням точної температури, вологості та рівня освітленості, неефективне використання ресурсів, таких як вода та поживні речовини, а також можливість людської помилки при моніторингу та регулюванні. Це робить контроль  максимально продуктивного середовища трудомістким процесом.
Доступність недорогих датчиків і досягнення в автоматизації пропонують рішення для цих проблем.  Програмне забезпечення, яке інтелектуально інтегрує дані про навколишнє середовище та автоматизує реагування, має потенціал для скорочення витрат на робочу силу, підвищення ефективності використання ресурсів, а також покращення якості та стабільності врожаю. Зі зростанням чисельності населення планети, що збільшує навантаження на системи виробництва продуктів харчування, такі програмні рішення стають все більш важливими.


1.1.2	Бізнес-можливості


Аналоги на ринку:
−	Argus Control Systems: Комплексне рішення, яке широко використовується в комерційних теплицях. Пропонує надійний моніторинг навколишнього середовища та автоматизацію, але має складний інтерфейс і високу ціну, що робить його менш придатним для невеликих підприємств.
−	FarmLogs: В першу чергу зосереджена на зборі даних і веденні обліку для широкого спектру сільськогосподарських операцій. Його специфічні для теплиць функції менш широкі, що обмежує його привабливість для спеціалізованих мікро-ферм.
−	Grodan GroSens: Мультисенсорна система, призначена для моніторингу субстрату. Надає цінну інформацію про стан кореневої зони, але не має інтеграції з іншими важливими компонентами автоматизації (освітлення, вентиляція тощо).
Переваги продукту порівняно з вищезгаданими аналогами на ринку:
−	Зручність для користувача: Пріоритетом є чистий, інтуїтивно зрозумілий інтерфейс, який робить автоматизацію доступною для фермерів з будь-яким рівнем досвіду, забезпечуючи явну перевагу над складними системами, такими як Argus.
−	Кастомізація: Пропонує гнучку платформу, де правила моніторингу та автоматизації можуть бути адаптовані до конкретних культур, клімату та умов вирощування. Ця адаптивність перевершує більш сфокусований підхід Grodan GroSens.
−	Доступність і гнучкість: Поєднує в собі недорогу базову підписку з додатковими модулями для масштабування. Ця модель забезпечує значну економію витрат на апаратне забезпечення порівняно з FarmLogs, яка може вимагати пропрієтарного обладнання.
Модель монетизації:
−	Багаторівнева підписка: Базовий моніторинг і контроль за низькою щомісячною вартістю, з преміум-рівнями для розширеної аналітики, звітності та індивідуальних правил автоматизації.
−	Апаратні партнерства: Розподіл доходів з рекомендованими виробниками датчиків та обладнання для автоматизації, що забезпечує сумісність та спрощує роботу користувачів.
−	Консалтингові послуги: Пропонує платну допомогу з кастомізації та оптимізації, надаючи експертні рекомендації для максимізації переваг системи.
Цільовий ринок:
−	Домашні мікроферми: Використовує зростаючу популярність домашнього виробництва продуктів харчування для особистого споживання та місцевих ринків.
−	Малі виробники: Орієнтований на міські фермерські господарства, навчальні заклади та нішевих виробників, що спеціалізуються на вирощуванні високоцінних культур і потребують адаптивних рішень.
Перспективи ринку:  Позиціонує себе як такий, що отримає вигоду від прогнозованого зростання сільського господарства з контрольованим середовищем, зумовленого занепокоєнням щодо продовольчої безпеки, сталого розвитку та прагненням до місцевої продукції. Роблячи автоматизацію доступною для широкої аудиторії, програмне забезпечення відповідає цим факторам зростання.


1.1.3	Бізнес-цілі та критерії успіху


BO-1: Підвищення ефективності та оптимізація ресурсів.
BO-2: Покращення здоров'я рослин та врожайності.
BO-3: Доступність та прийняття користувачами.
SC-1: Продемонструвати кількісне скорочення робочих годин на управління теплицями/мікрофермами в середньому на 25% для користувачів протягом перших 6 місяців.
SC-2: Досягти середнього скорочення використання води та енергії на 10% для користувачів протягом одного року.
SC-3: Користувачі повідомляють про середнє збільшення врожайності на 15% після одного року постійного використання системи.
SC-4: Високий відсоток користувачів (>80%) повідомляють про зменшення випадків втрати врожаю через стресові фактори навколишнього середовища (шкідники, хвороби, нестача поживних речовин).
SC-5: Досягти показника індексу підтримки користувачів 70 або вище, що свідчить про високий рівень задоволеності та підтримки користувачів.
SC-6: Досягти 1 000 активних підписників протягом першого року роботи.
SC-7: Створити спільноту підтримки із середнім часом відгуку менше 24 годин для вирішення проблем користувачів.


1.1.4	Потреби клієнтів та ринку


Програмна система спрямована на вирішення наступних проблем та прагнень, які часто виникають у наших цільових аудиторій:
Домашні мікрофермери:
−	Бажання більшого контролю та оптимізації: Багатьма домашніми фермерами рухає бажання посилити контроль над виробництвом продуктів харчування та досягти максимальних врожаїв на обмеженій площі.
−	Обмеженість часу та ресурсів: Поєднання управління мікрофермою з повсякденним життям може бути непростим завданням. Інструменти, які спрощують завдання та зменшують трудовитрати, дуже цінуються.
−	Потреба в знаннях та підтримці: Ентузіазм часто випереджає досвід. Доступне керівництво та підтримка спільноти мають вирішальне значення для успіху, особливо для початківців.
Малі комерційні виробники:
−	Тиск на підвищення врожайності та якості: Необхідність максимізувати вихід продукції з квадратного футу та забезпечити стабільно високу якість продукції є життєво важливою для прибутковості.
−	Управління зростаючими витратами: Оптимізація використання ресурсів (вода, енергія, робоча сила) має важливе значення для підтримки низького рівня рентабельності.
−	Прийняття рішень на основі даних: Здатність відстежувати тенденції та визначати сфери для вдосконалення стає все більш важливою в міру масштабування операцій.
Потреби, спільні для всіх сегментів клієнтів:
−	Простота використання: Надто складні системи створюють бар'єр для входу, особливо для тих, хто не має глибокої технічної підготовки.
−	Доступність: Вартість є основним фактором, при цьому рішення повинні демонструвати чітку окупність інвестицій (ROI).
−	Надійність: Системи повинні бути надійними та надійними, оскільки здоров'я рослин часто залежить від їхньої безперебійної роботи.


1.1.5	Бізнес-ризики


Впровадження технологій: Деякі виробники не поспішають впроваджувати автоматизацію, віддаючи перевагу традиційним методам.
Пом'якшення наслідків: Наголошувати на навчанні користувачів, надаючи наочні демонстрації рентабельності інвестицій. Налагоджувати партнерські відносини з перевіреними постачальниками або навчальними закладами. 
Проблеми масштабування:  Забезпечення здатності програмного забезпечення та інфраструктури підтримки впоратися зі стрімким зростанням, якщо кількість користувачів випереджає прогнози.
Пом'якшення наслідків: Використовувати хмарні рішення для масштабування. Розробляти модульну архітектуру для поетапного розгортання розширених функцій. Заздалегідь планувати потреби в підтримці клієнтів, що зростають.
Безпека та конфіденційність даних: Завоювання довіри користувачів до того, як обробляються конфіденційні дані про врожай та навколишнє середовище.
Пом'якшення наслідків: Впроваджувати надійні заходи кібербезпеки з самого початку. Бути прозорими щодо політики використання даних. Розглянути можливість отримання сертифікатів конфіденційності, якщо це можливо.
Залежність від постачальників обладнання: Перебої в ланцюжку постачання датчиків або компонентів автоматизації можуть вплинути на функціональність системи.
Пом'якшення наслідків: Прагнути до сумісності з різними постачальниками. Підтримувати буферний запас критично важливих компонентів, якщо це можливо. Встановлювати чіткі лінії зв'язку з партнерами з постачання обладнання.


1.2 	Концепція рішення

1.2.1	Окреслення концепції


Цей проект має на меті розширити можливості як домашніх мікроферм, так і малих комерційних виробників за допомогою інтелектуальної програмної системи, призначеної для впорядкування та оптимізації управління теплицями та мікрофермами.  Основними цілями є:
−	Автоматизація навколишнього середовища: Система буде точно регулювати такі критичні фактори, як температура, вологість, рівень освітленості та подача поживних речовин, забезпечуючи оптимальні умови вирощування цілодобово. Це зменшує ручну працю, покращує однорідність врожаю та максимізує врожайність.
−	Ефективне використання ресурсів: Інтелектуальний моніторинг і контроль оптимізують використання води, добрив та енергії. Це означає зниження операційних витрат і більш сталий підхід до виробництва.
−	Покращене прийняття рішень: Система збиратиме та аналізуватиме дані з плином часу, надаючи цінну інформацію про продуктивність сільськогосподарських культур. Такий підхід, заснований на даних, дозволяє виробникам вносити обґрунтовані корективи для постійного вдосконалення.
Ключова перевага: Спрощуючи та автоматизуючи основні процеси управління, це програмне рішення дасть можливість виробникам вирощувати більш якісні культури з більшою ефективністю, що в кінцевому підсумку зменшить витрати на робочу силу та підвищить прибутковість.


1.2.2	Головна функціональність


MF-1: Моніторинг у реальному часі та візуалізація даних:
−	датчики безперервно контролюють ключові параметри навколишнього середовища (температуру, вологість, інтенсивність світла, вологість ґрунту, рівень поживних речовин тощо);
−	дані представлені на інтуїтивно зрозумілій інформаційній панелі з налаштованими параметрами відображення (графіки, діаграми, сповіщення);
−	історичні дані зберігаються для аналізу тенденцій та оптимізації.
MF-2: Автоматизація екологічного контролю:
−	користувачі встановлюють бажані діапазони температури, вологості та освітленості;
−	програмне забезпечення автоматично керує системами вентиляції, опалення/охолодження, освітлення та затінення, щоб підтримувати оптимальні умови;
−	автоматизація на основі правил дозволяє вносити корективи залежно від часу, даних про навколишнє середовище або стадії росту.
MF-3: Зрошення та управління поживними речовинами:
−	автоматизоване планування зрошення на основі типу культури, стадії росту та даних датчиків (вологість ґрунту);
−	точна фертигація (доставка поживних речовин через зрошення) з розрахунком і контролем дозування.
MF-4: Сповіщення:
−	користувачі отримують сповіщення (додаток) про умови, що виходять за межі діапазону, або системні події.
MF-5: Віддалений доступ і мобільний додаток:
−	моніторинг та керування системою з будь-якого місця, де є доступ до Інтернету;
−	мобільний додаток призначений для легкого управління ключовими функціями.
MF-6: Інтеграція з інтелектуальними датчиками та обладнанням для автоматизації:
−	сумісність з широким спектром датчиків і виконавчих пристроїв (температура/вологість, світло, вологість ґрунту, насоси, вентилятори тощо).
MF-7: Безпека та управління даними:
−	автоматичне резервне копіювання даних забезпечує захист від втрати даних;
−	зручні інструменти для експорту даних для подальшого аналізу або інтеграції;
−	безпечний функціонал імпорту даних для завантаження показань датчиків або конфігурацій із зовнішніх джерел.
MF-8: Локалізація та мовна підтримка:
−	підтримує англійську та українську мови для доступності для ширшого кола користувачів.


1.2.3	Припущення та залежності


Припущення:
−	Базові знання про рослини: Користувачі мають фундаментальне розуміння вимог до росту рослин (світло, температура, поживні речовини), що стосуються їхніх культур.
−	Надійний Інтернет: Функціональні можливості системи, що залежать від віддаленого доступу та аналізу даних, вимагають стабільного інтернет-з'єднання.
−	Апаратна сумісність: Користувачі будуть використовувати датчики та обладнання для автоматизації, які або входять до рекомендованого списку системи, або можуть бути інтегровані за допомогою підтримуваних протоколів.
−	Належне встановлення: Користувачі несуть відповідальність за правильне встановлення та конфігурацію датчиків і виконавчих механізмів відповідно до інструкцій системи.
Залежності:
−	Мобільний пристрій: Для повного використання мобільного додатку потрібен сумісний смартфон або планшет.
−	Джерело живлення: Датчики, обладнання для автоматизації та будь-яке мережеве обладнання потребують стабільного джерела живлення.
−	Регулярне технічне обслуговування: Датчики можуть потребувати періодичного калібрування або очищення для забезпечення точного збору даних.
−	Оновлення системи: Користувачам потрібно буде встановлювати оновлення програмного забезпечення, щоб скористатися новими функціями, виправленнями безпеки та покращеною продуктивністю.


1.3 	Рамки та обмеження

1.3.1	Рамки первинного випуску


Backend:
−	База даних: Зберігає всі важливі дані, такі як: показники навколишнього середовища (температура, вологість, освітленість тощо); профілі та налаштування користувачів; правила та розклади автоматизації; системні журнали та події.
−	Обробка та аналіз даних: Виконує статистичний аналіз даних з датчиків; застосовує алгоритми оптимізації для планування ресурсів (полив, подача поживних речовин); генерує сповіщення на основі визначених користувачем правил.
−	Бізнес-логіка: Керує основними правилами системи та тригерами автоматизації; обробляє запити на конфігурацію користувача; виконує заплановані завдання.
−	Сервер API: Забезпечує безпечні кінцеві точки для зв'язку з фронтендом і мобільними додатками; обробляє запити даних, оновлення та автентифікацію.
−	Безпека: Забезпечує автентифікацію та авторизацію користувачів; реалізує шифрування даних; підтримує безпечні протоколи зв'язку.
Frontend (веб-панель керування):
−	Візуалізація даних: Відображає показники навколишнього середовища в реальному часі, а також сповіщення.
−	Автоматизація управління: Дозволяє встановлювати/редагувати параметри контролю навколишнього середовища; дозволяє створювати та керувати правилами автоматизації; дозволяє видаляти дані. 
−	Конфігурація системи: Управління профілями користувачів; системні налаштування та уподобання.
−	Адаптивний дизайн: Забезпечує доступність на різних розмірах екрану (настільний комп'ютер, планшет).
Мобільний додаток:
−	Спрощений моніторинг: Відображає екологічні дані в реальному часі у зручному для користувача форматі.
−	Сповіщення: Надає критичні сповіщення та сповіщення про системні події.
−	Нативний досвід роботи з додатком: Оптимізовано для мобільних операційних систем (Android, iOS) для швидкості та зручності використання.
IoT:
−	Датчики: Збирають дані про температуру, вологість, інтенсивність світла, вологість ґрунту тощо; передають дані до внутрішньої системи.
−	Сповіщення: Надсилає сповіщення про вихід показників за дозволені межі значень. 


1.3.2	Рамки наступних випусків


У наступних випусках продукту планується впровадження додаткових функцій, спрямованих на поліпшення користувацького досвіду та збільшення можливостей для користувачів.
Розширена функціональність підписок: Преміум-підписки розблокують розширені функції, пристосовані до різних потреб користувачів. До них відносяться:
−	Поглиблена аналітика: Інструменти для відстеження тенденцій, оптимізації умов та вдосконалення методів вирощування.
−	Поради для конкретних рослин: Детальні профілі догляду з індивідуальними рекомендаціями для широкого спектру культур, а також рослин, які вирощуються в домашніх умовах.
−	Доступ до спільноти: Спілкування з іншими фермерами, можливість ділітися знаннями та черпайте натхнення.
−	Розширені профілі рослин (преміум-функція): Користувачі з підпискою можуть створювати комплексні профілі рослин, щоб мати повних список всіх наявних рослив та можливість детальніше відслідковувати умови, в який знаходиться кожна з них.
Аналітика на основі даних: Впровадження потужних аналітичних інструментів (доступні за підпискою), щоб допомогти користувачам:
−	візуалізувати показники росту рослин з плином часу;
−	визначати закономірності та області для вдосконалення;
−	отримувати вигоду від персоналізованих порад щодо оптимізації.
Створення спільноти:  Сприяйняття створенню активної спільноти, де користувачі можуть:
−	обмінюватися порадами, досвідом та демонструвати свої успіхи;
−	звертатися за підтримкою та вчитися у досвідчених фермерів.
Інтелектуальні дані на основі місцезнаходження:  Інтегрування функцій геолокації, щоб:
−	надавати рекомендації щодо оптимальних умов вирощування для конкретного клімату;
−	пропонувати успішні місцеві сорти рослин.


1.3.3	Обмеження та виключення


Обмеження:
−	Апаратна сумісність: Початковий випуск підтримуватиме певний перелік датчиків та пристроїв автоматизації. Розширена сумісність буде поетапно впроваджуватися протягом наступних випусків.
−	Залежність від Інтернету: Віддалений доступ, сповіщення та певні функції системи потребують надійного підключення до Інтернету.
−	Компетентність користувача: Хоча система розроблена таким чином, щоб бути зручною для користувача, вона передбачає базовий рівень розуміння вимог до вирощування рослин та навколишнього середовища.
−	Масштаб автоматизації: Початкова версія буде зосереджена на основних засобах екологічного контролю. Інтеграція з більш спеціалізованим обладнанням буде дозволена в майбутніх версіях.
Винятки:
−	Встановлення/вирішення проблем на місці: Програмне забезпечення не включає фізичне встановлення датчиків або налаштування обладнання. Користувачам може знадобитися проконсультуватися з технічним спеціалістом або скористатися наданими ресурсами та навчальними посібниками.
−	Гарантія результатів: Хоча система призначена для оптимізації умов вирощування, на врожайність і якість сільськогосподарських культур впливають численні фактори, які не піддаються контролю з боку програмного забезпечення (якість насіння, шкідники, хвороби тощо).
−	Повна відповідність нормативним вимогам: Користувач несе відповідальність за те, щоб його теплиця/мікроферма відповідала всім місцевим нормам і стандартам безпеки, особливо при автоматизації електрообладнання.

1.4 	Бізнес-контекст

1.4.1	Профілі зацікалених сторін


На таблиці 1 описані профілі зацікавлених сторін:


Таблиця 1 – Профілі зацікавлених сторін 
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Власники мікроферм	Моніторинг в реальному часі, автоматизовані налаштування, зручний інтерфейс	Ентузіазм, бажання вчитися, бережливе ставлення до витрат	Простота використання, більша врожайність, економія часу, освітні ресурси		Обмежений бюджет, може мати обмежений технічний досвід
Малі бізнеси	Оптимізація навколишнього середовища, інтеграція з існуючими системами	Орієнтований на результат, потребує підтвердження рентабельності інвестицій		Економія коштів за рахунок ефективності, надійної роботи		Необхідність максимізації врожаю з обмеженого простору, зростаючі витрати на ресурси	


Продовження таблиці 1
Дослідники/
навчальні заклади		Налаштовуваний експорт даних, потенціал для розширеної інтеграції датчиків	Зосереджені на точності та дослідженні		Доступ до детальних даних, гнучкість для експериментальних установок		Можуть мати специфічні потреби у зборі даних	


1.4.2	Пріорітети проекту


На таблиці 2 наведені основні пріорітети проєкту:


Таблиця 2 – Основні пріорітети проєкту 
Показник	Опис	Пріорітет
План робіт	Реліз версії 1.0 повинен бути доступний до 31.05.2024.	Високий
Функціональність	Наявність всього зазаначеного функціоналу версії 1.0
	Високий
Якість	Система повинна бути стабільною, працювати без збоїв, бути доступною в будь-який час.	Високий
	
Продовження таблиці 2
Персонал	Розмір команди – 1 людина	Середній
Ціна	Обмежений бюджет	Середній


1.4.3	Робоче середовище


Проект буде використовувати комбінацію технологій та програмних засобів для забезпечення надійності, продуктивності, масштабованості та безпеки:
−	Backend Framework: Ядро ASP.NET Core буде працювати на стороні сервера, забезпечуючи надійну основу для ефективної роботи та спрощеної розробки.
−	Веб-інтерфейс: HTML5, CSS3, React та JavaScript об'єднаються для створення адаптивного, зручного веб-інтерфейсу, що забезпечує доступність на всіх пристроях.
−	Мобільний додаток: .NET MAUI буде використовуватися завдяки своїм перевагам у продуктивності та сумісності з широким спектром пристроїв на базі Android.
−	ІоТ платформа: Arduino через її доступність, підтримку спільноти та простоту інтеграції з різними датчиками та виконавчими механізмами;
−	ІоТ програмування: C/C++ для ефективного використання ресурсів та низькорівневого керування обладнанням.
−	ІоТ бібліотеки: Конкретні бібліотеки будуть обрані на основі вимог датчиків та актуаторів, забезпечуючи сумісність та комунікацію.
−	База даних: Буде використано СУБД PostgreSQL через її надійність, масштабованість та перевірений досвід роботи з системами такого типу.
Безпека:
−	сучасні стандарти автентифікації та авторизації для захисту інформації користувача та доступу до системи;
−	найкращі практики безпеки при розробці коду для зменшення вразливостей.
Доступність та надійність:
−	розгортання на хмарній платформі для масштабованості та високої доступності;
−	постійний моніторинг та проактивне обслуговування для мінімізації простоїв.


2 	ПОСТАНОВКА ЗАДАЧІ


Метою проекту є розробка високопродуктивної програмної системи, що забезпечує контроль та моніторинг тепличного середовища або середовища домашніх мікроферм.
Для детального розуміння можливостей користувача, була розроблена UML-діаграма прецедентів (див. А.1).
За допомогою програмної системи, користувачі матимуть змогу:
Зареєструватися в системі:
−	нові користувачі матимуть можливість легко створити особистий обліковий запис, ввівши необхідну інформацію (ім'я, контактні дані тощо) і вибравши унікальну комбінацію імені користувача та пароля.
Входити в систему при наявності вже створенного облікового записа:
−	матимуть безпечний доступ до системи з використанням встановлених облікових даних.
Переглядати/редагувати інформацію в обліковому записі:
−	користувачі зможуть переглядати та оновлювати інформацію про свій обліковий запис, включаючи особисті дані та контактну інформацію.
Моніторити та керувати датчиками:
−	система надає чіткий огляд поточних показань датчиків для різних параметрів у декількох теплицях;
−	користувачі матимуть можливість віддалено налаштовувати порогові значення та параметри датчиків;
−	користувачі зможуть розширити діапазон контрольованих параметрів, додаючи нові датчики або видаляючи непотрібні.
Отримувати екстрені сповіщення:
−	система активно відстежує дані датчиків і негайно сповіщає користувачів електронною поштою про перевищення критичних порогових значень. Це дозволяє швидко втрутитися, щоб запобігти пошкодженню або втраті врожаю через екстремальні коливання температури, перебої в електропостачанні, несправності обладнання або інші надзвичайні ситуації.


3 	ПРОЕКТУВАННЯ БАЗИ ДАНИХ


Для проєктування бази даних було розроблено ER діаграму (див. А.2). Усього база даних містить 5 таблиць та 15 неключових атрибутів, про які детальніше написано нижче.
Було виявлено, що один користувач може мати декілька різних теплиць, але кожна теплиця може належати лише одному користувачу.
Також зрозуміло, що одна теплиця може мати багато датчиків для вимірювання різних показників, але один датчик може належати лише одній теплиця.
Крім того, один датчик може мати кілька розкладів роботи, в свою чергу один розклад може належати лише одному датчику.
Також виявлено, що одна інформація з датчика може мати одне повідомлення про зміну показників та одне повідомлення може відноситися лише до однієї інформації з датчика.
Крім того, один датчик може мати багато інформації про його значення, збереженої в різні проміжки часу, але інформація про датчик може відноситися тільки до одного датчика.


4 	РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ
4.1 	Загальна архітектура системи


Програмна система для теплиць та мікроферм має модульну архітектуру. Система складається з п’яти основних компонентів: 
−	база даних;
−	серверна частина; 
−	рівень IoT;
−	веб-додаток;
−	мобільний додаток.
 Кожен компонент відіграє важливу роль у загальній функціональності та продуктивності системи. А також така модульність не тільки підвищує продуктивність системи, але й полегшує її розширення та модернізацію в майбутньому, забезпечуючи довгострокову стійкість і адаптивність у сфері сільського господарства з контрольованим середовищем, що розвивається.


4.2 	Розробка серверної частини

4.2.1	Архітектура серверної частини


Для розробки серверної складової нашої системи ми використовували діаграму розгортання (див. А.3), ключовий інструмент в мові UML. Цей графічний інструмент не лише формулює фізичну архітектуру системи, але й глибоко аналізує місцезнаходження та взаємодії між компонентами. Використання діаграми розгортання полегшує не лише проектування та аналіз системи, але й забезпечує оптимізацію фізичної структури. Цей підхід робить зрозумілішими взаємодії компонентів та сприяє раціональній розробці фізичної архітектури системи.
Паралельно з цим, була створена діаграма станів (див. А.4). Ця діаграма детально відображає можливі стани системи, події, що можуть спричинити переходи між ними, а також конкретні дії в кожному стані. Вона є не лише ефективним інструментом для аналізу та визначення поведінки системи, але й надійним засобом урахування можливих взаємодій та переходів під час взаємодії користувачів із системою.
Важливо відзначити, що цей підхід допомагає не лише створити ефективну архітектуру системи, але й покращити процеси розробки та взаємодії з користувачами.


4.2.2	Розробка сервера


Для розробки серверної частини нашого проекту було обрано ASP.NET Core Web API та мову програмування C#. Для зручності розробки використовувався Visual Studio.
Ця технологічна комбінація дозволила швидко і ефективно створити потужний сервер для проекту. ASP.NET Core Web API надав можливість створювати веб-сервіси, а мова C# відмінно підходить для програмування серверної логіки. Використання Visual Studio додатково спростило процес розробки, забезпечуючи зручну інтеграцію з ASP.NET Core. Також було використано ORM Entity Framework.


4.2.3	REST специфікація


Greenhouse:
−	GET api/greenhouses/ – отримати всі наявні теплиці;
−	POST api/greenhouses/ – додати нову теплицю;
−	GET api/greenhouses/{greenhouseId} – отримати потрібну теплицю за Id;
−	PUT api/greenhouses/{greenhouseId} –  змінити обрану за Id теплицю;
−	DELETE api/greenhouses/{greenhouseId} – видалити обрану за Id теплицю;
−	GET api/greenhouses/byUserId/{userId} – отримати всі теплиці одного користувача.
Notification:
−	GET api/notifications/ – отримати всі наявні повідомлення;
−	POST api/notifications/ – додати нове повідомлення;
−	GET api/notifications/{notificationId} – отримати потрібне повідомлення за Id;
−	PUT api/notifications/{notificationId} – змінити обране за Id повідомлення;
−	DELETE api/notifications/{notificationId} – видалити обране Id за повідомлення;
−	GET api/notifications/bySensorId/{sensorId} – отримати всі повідомлення, які відносяться до одного датчика.
Schedule:
−	GET api/schedules/ – отримати всі наявні розклади;
−	POST api/schedules/ – створити новий розклад;
−	GET api/schedules/{scheduleId} – отримати обраний за Id розклад;
−	PUT api/schedules/{scheduleId} – змінити обраний за Id розклад;
−	DELETE api/schedules/{scheduleId} – видалити обраний за Id розклад;
−	GET api/schedules/bySensorId/{sensorId} – отримати всі розклади, які пов’язані з одним датчиком.
Sensor:
−	GET api/sensors/ – отримати всі наявні датчики;
−	POST api/sensors/ – додати новий датчик;
−	GET api/sensors/{sensorId} – отримати обраний за Id датчик;
−	PUT api/sensors/{sensorId} – змінити обраний за Id датчик;
−	DELETE api/sensors/{sensorId} – видалити обраний за Id датчик;
−	GET api/sensors/byGreenhouseId/{greenhouseId} – отримати всі датчики, які пов’язані з однією теплицею.
SensorReading:
−	GET api/sensorsReadings/ – отримати всю інформацію з датчиків;
−	POST api/sensorsReadings/ – додати нову інформацію з датчика;
−	GET api/sensorsReadings/{sensorsReadingsId} – отримати обрану за Id інформацію з датчика;
−	PUT api/sensorsReadings/{sensorsReadingsId} – змінити обрану за Id інформацію з датчика;
−	DELETE api/sensorsReadings/{sensorsReadingsId} – видалити обрану за Id інформацію з датчика.
User:
−	GET api/users/ – отримати всіх наявних користувачів;
−	POST api/users/ – додати нового користувача;
−	GET api/users/{userId} – отримати обраного за Id користувача;
−	PUT api/users/{userId} – змінити обраного за Id користувача;
−	DELETE api/users/{userId} – видалити обраного за Id користувача;
−	POST api/users/login – вхід в систему;
−	POST api/users/logout – вихід з системи.


4.3 	Розробка IoT девайсу

4.3.1	Архітектура IoT девайсу


Початок розробки програмного забезпечення для IoT-пристрою відбувся на мові програмування C++ у віртуальному середовищі симуляції Wokwi. Для емуляції фізичної системи використовувався мікроконтроллер ESP32, обладнаний можливістю підключення до мережі та виходу в інтернет — це важливо для взаємодії з серверною частиною. В комплекті до пристрою входив сенсор DHT22 для вимірювання вологості та температури.
Цей підхід дозволяє не лише програмно тестувати функціональність пристрою, але і ефективно моделює його роботу в умовах, що найбільше наближені до реальних. Використання мікроконтроллера ESP32 гарантує стабільне з'єднання з мережею та доступ до інтернету, що є ключовим для ефективної роботи з серверною частиною.


4.3.2	Розробка системи для IoT девайсу


Перед початком написання коду було створено схему для фізичного розміщення частин системи (див. А.5).
В головному файлі програми використовуються такі бібліотеки (див. Б.1, рядки 1-7):
− WiFi.h: Для роботи з Wi-Fi модулем ESP32 і підключення до бездротової мережі.
− HTTPClient.h: Взаємодія з HTTP-серверами.
− ArduinoJson.h: Робота з форматом JSON на платформі Arduino.
− DHT.h: Взаємодія з датчиками температури та вологості.
Файл «wifi-scan.ino» реалізує систему моніторингу теплиці на основі Wi-Fi. Вона підключається до заданої мережі WiFi та ініціалізує різні компоненти, включаючи датчики та конфігурацію часу. Основні функціональні можливості включають:
−	Підключення до WiFi: Підключається до вказаної мережі WiFi.
−	Синхронізація часу: Синхронізує час із сервером NTP.
−	Аутентифікація користувача: Аутентифікація користувача та перевірка облікових даних на віддаленому сервері.
−	Ініціалізація теплиці: Ініціалізує систему теплиці, отримуючи дані датчиків із сервера.
−	Моніторинг датчиків: Здійснює моніторинг датчиків (температури та вологості) і повідомляє про відхилення, якщо система керування увімкнена.
−	Звітність даних: Звітує про показання датчиків та сповіщення на віддалений сервер на основі певних умов.
«InitUserGreenhouse.h» містить функцію автентифікації користувача шляхом надсилання запиту на вхід на віддалений сервер і перевірки облікових даних користувача. 
«Sensor.h» визначає структуру датчика, яка включає методи перевірки стану датчика та відправлення повідомлення користувачу за необхідності. Використовує розклад для визначення періодів активного моніторингу та зв'язується з віддаленим сервером для публікації показань датчика та сповіщень.
«Greenhouse.h» визначає структуру Greenhouse, яка відповідає за ініціалізацію датчиків шляхом отримання їхньої конфігурації з віддаленого сервера. Вона містить список датчиків, які контролюються в теплиці.
«Schedule.h» визначає структуру Schedule і містить статичний метод для отримання розкладу моніторингу для певного датчика з віддаленого сервера. Розклади визначають активні періоди для моніторингу датчиків.
«Notification.h» містить функції для надсилання показань датчиків та сповіщень на віддалений сервер. Він форматує дані у JSON і обробляє HTTP-зв'язок. Сповіщення генеруються, коли показники датчика відхиляються від налаштованого діапазону.


4.4 	Розробка веб-застосунку

4.4.1	Архітектура веб-застосунку


Система була розроблена з використанням фреймворку React в рамках компонентної архітектури. 
Для зв'язку з базою даних за допомогою бекенд-методів було використано PostgreSQL. Така інтеграція з базою даних забезпечує ефективне управління та пошук даних, що є важливим для функціональності системи.
Використання React забезпечує чуйний і динамічний користувальницький інтерфейс, а компонентна архітектура сприяє чіткому поділу завдань, підвищуючи легкість обслуговування і масштабованість коду.
Поєднання існуючого бекенду з React-додатком забезпечує надійне середовище розробки, яке сприяє ефективному кодуванню, налагодженню та розгортанню процесів. Таке налаштування має вирішальне значення для забезпечення безперебійного та надійного користувацького досвіду в управлінні системою догляду за теплицями та мікрофермами.


4.4.2	Розробка системи для веб-застосунку


Перед початком процесу розробки була накреслина UML діаграма діяльності (див. A.3), щоб проілюструвати фізичні та логічні компоненти системи.
Основна програма використовує декілька бібліотек та залежностей, перелічених нижче:
−	react: Для побудови користувацького інтерфейсу та керування станами компонентів.
−	react-intl: Для інтернаціоналізації та локалізації текстового вмісту.
−	react-router-dom: Для навігації та маршрутизації всередині програми.
−	local-storage: Для зберігання та отримання даних користувача.
−	context: Для управління глобальним станом та забезпечення контексту у всьому додатку.
Основні сторінки, до яких має доступ користувач:
Файл GreenhousesPage.jsx реалізує інтерфейс для управління теплицями. Він з'єднується з бекендом через API-сервіси і виконує різні операції, зокрема:
−	отримує список теплиць, пов'язаних з користувачем, що увійшов в систему;
−	дозволяє додавати, редагувати, видаляти та переглядати датчики теплиць;
−	керує та відображає повідомлення про помилки, пов'язані з отриманням даних та операціями.
Файл NotificationsPage.jsx зосереджений на управлінні сповіщеннями користувача. Він включає такі функції, як:
−	отримує сповіщення для користувача з бекенду;
−	керує помилками під час отримання даних і відображає відповідні повідомлення;
−	дозволяє користувачам видаляти сповіщення та відповідно оновлює інтерфейс користувача.
Файл SensorsPage.jsx відповідає за управління датчиками в теплиці. Основні функції включають:
−	отримує список датчиків для конкретної теплиці;
−	надає можливість додавати, редагувати, видаляти та переглядати графіки роботи датчиків;
−	реалізує сортування за різними атрибутами датчиків для покращення роботи користувача.
Файл UserAccountPage.jsx керує даними облікового запису користувача і надає такі функції, як:
−	дозволяє користувачам переглядати та редагувати дані свого облікового запису;
−	обробляє вихід користувача з системи та оновлює інформацію про користувача у локальному сховищі;
−	керування та відображення помилок, пов'язаних з оновленням даних користувача.
Також проект містить провайдери контексту для керування глобальним станом:
−	AuthContext: Керує станом автентифікації користувача, зокрема функціями входу і виходу з системи.
−	LanguageContext: Керує мовними налаштуваннями програми та надає методи для зміни мови.
Папка models визначає моделі даних, що використовуються в додатку, забезпечуючи узгодженість структур даних і перевірку типів.
Папка services містить службові файли API, такі як GreenhouseService.js, NotificationService.js, SensorService.js та інші, які обробляють HTTP-запити до бекенду для виконання CRUD-операцій.
Папка styles містить файли CSS, які використовуються для стилізації різних компонентів і сторінок, забезпечуючи послідовний і візуально привабливий користувацький інтерфейс.
Загалом, така модульна структура та чіткий розподіл завдань полегшує обслуговування, масштабування та ефективну розробку фронтенд-системи.


4.5 	Розробка мобільного застосунку

4.5.1	Архітектура мобільного застосунку


Основою проекту є фреймворк .NET MAUI, який дотримується патерну MVVM для добре структурованої кодової бази. Розроблений на C# з використанням xaml, він взаємодіє з серверною частиною для ефективного управління даними. Ця комбінація, разом з IDE Visual Studio, забезпечує спрощений процес розробки комплексної системи догляду за теплицями та мікрофермами.


4.5.2	Розробка системи для мобільного застосунку


Основна програма використовує декілька сервісів, моделей, вьюмоделей та представлень, які перелічені нижче:
Сервіси в мобільному додатку відповідають за зв'язок з внутрішнім API і виконують CRUD-операції. Основні сервіси включають:
−	AuthService: Керує процесами автентифікації та авторизації користувачів, включаючи вхід, реєстрацію, оновлення інформації про користувача та вихід з системи.
−	SensorService: Обробляє операцію, пов'язану з датчиками, таку як отримання датчиків користувача.
−	UserService: Керує операціями, пов'язаними з користувачами, включаючи отримання всіх користувачів, створення, оновлення та видалення облікових записів користувачів.
−	GreenhouseService: Відповідає за операцію, пов'язану з теплицями, таку як отримання теплиць, пов'язаних з увімкненим користувачем.
−	NotificationService: Відповідає за операцію, пов'язану зі сповіщеннями користувачів, таку як отримання сповіщеннь.
Папка models визначає структури даних, що використовуються в додатку, забезпечуючи узгодженість і перевірку типів.
ViewModels відповідають за підготовку даних та обробку взаємодії з користувачем. 
Views представляють користувацький інтерфейс і включають різні сторінки, з якими взаємодіють користувачі. 
Програма використовує постачальників контексту для керування глобальними станами, такими як автентифікація та мовні налаштування:
−	AuthContext: Керує станом автентифікації користувача, включно з функціями входу і виходу з системи.
−	LanguageContext: Керує мовними налаштуваннями програми та надає методи для зміни мови.


ВИСНОВКИ


Розробка програмного забезпечення для управління теплицями та домашніми мікро-фермами є значним кроком вперед у галузі сільського господарства з контрольованим середовищем. Цей проект продемонстрував, як сучасні технології можуть бути використані для оптимізації продуктивності сільського господарства, підвищення ефективності використання ресурсів та сприяння сталому веденню сільського господарства. Завдяки інтеграції надійної серверної частини, передового рівня Інтернету речей, зручного інтерфейсу та універсального мобільного додатку, система забезпечує комплексне рішення як для комерційних операторів теплиць, так і для міських садівників.
В ході проекту були вирішені такі ключові завдання, як ефективне управління ресурсами, моніторинг навколишнього середовища в режимі реального часу та доступність для користувачів. Впровадження датчиків і виконавчих механізмів дозволило точно контролювати критичні умови вирощування, а алгоритми аналізу даних і автоматизації сприяли прийняттю обґрунтованих рішень і підвищенню операційної ефективності. Модульна архітектура системи забезпечує масштабованість та адаптивність, що дозволяє їй розвиватися разом з технологічним прогресом та зміною потреб користувачів.
Таким чином, ця програмна система не тільки відповідає сучасним вимогам сільського господарства з контрольованим середовищем, але й закладає основу для майбутніх інновацій. Продовжуючи вдосконалювати і розширювати цю систему, ми зможемо ще більше посилити її можливості і вплив. 


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
1.	Код з проектом. URL:
https://github.com/NurePavlovskyiIhor/apzkr-pzpi-21-2-pavlovskyi-ihor
2.	Посилання на Wokwi з кодом ІоТ частини проекту. URL:
https://wokwi.com/projects/398881568827459585
3.	Методичні вказівки до курсової роботи. URL:
https://drive.google.com/file/d/18PO5WTIep_zIZ274ry0QAXVJnZjywEiE/view 
4.	Документація ДСТУ. URL:
https://dl.nure.ua/mod/page/view.php?id=536177
5.	Посилання на демонстрацію всіх складових проекта. URL:
https://youtu.be/S1hSk_N4-C4


ДОДАТОК А
Діаграми
А.1 UML-діаграма прецедентів
 
Рисунок 1 - UML-діаграма прецедентів


А.2 ER-модель даних
 
Рисунок 2 - ER-модель даних


А.3 UML діаграма розгортання
 
Рисунок 3 - UML діаграма розгортання


А.4 UML діаграма станів
 
Рисунок 4 - UML діаграма станів


А.5 Схема фізичної моделі системи
 
Рисунок 5 - Схема фізичної моделі системи


ДОДАТОК Б
Код ІоТ девайсу
Файл «wifi-scan.ino»:
1  #include "WiFi.h"
2  #include <HTTPClient.h>
3  #include <ArduinoJson.h>
4  #include <DHT.h>
5  #include <RTClib.h>
6  #include "InitUserGreenhouse.h"
7  #include "Greenhouse.h"
8  
9  #define NTP_SERVER     "pool.ntp.org"
10 #define UTC_OFFSET     3600
11 #define UTC_OFFSET_DST 0
12 
13 const String ssid = "Wokwi-GUEST";
14 const String password = "";
15 const String serverUrl = "http://0.tcp.eu.ngrok.io:15573/";
16 
17 int userId = -1;
18 
19 String user_email = "user3@example.com";
20 String user_password = "stringA";
21 
22 int controlSystemId = 2;
23 
24 const int DHTPin = 4;
25 const int switchPin = 17;
26 
27 Greenhouse greenhouse;
28 DHT dht(DHTPin, DHT22);
29 
30 void setup() {
31   Serial.begin(115200);
32   WiFi.begin(ssid, password);
33   while (WiFi.status() != WL_CONNECTED) {
34     delay(1000);
35     Serial.println("Connecting to WiFi...");
36   }
37   Serial.println("Connected to WiFi");
38 
39   userId = InitUserId(user_email, user_password, controlSystemId, serverUrl);
40 
41   configTime(UTC_OFFSET, UTC_OFFSET_DST, NTP_SERVER);
42   tm timeInfo;
43   getLocalTime(&timeInfo);
44   char formattedTime[20];
45   strftime(formattedTime, sizeof(formattedTime), "%Y-%m-%d %H:%M:%S", &timeInfo);
46   Serial.println("Local time: " + String(formattedTime)); 
47 
48   greenhouse = Greenhouse(controlSystemId, serverUrl);
49 }
50 
51 void loop() 
52 {
53   static tm timeInfo;
54   getLocalTime(&timeInfo);
55   
56   if(digitalRead(switchPin) == 0)
57   {
58     for(auto& sensor : greenhouse.sensors)
59     {
60       float currentReadings;
61       float acceptableDeviation;
62 
63       switch(sensor.sensorType)
64       {
65       case 0:
66       currentReadings = dht.readTemperature();
67       acceptableDeviation = 1.0;
68       break;
69 
70       case 1:
71       currentReadings = dht.readHumidity();
72       acceptableDeviation = 0.75;
73       break;
74       }
75 
76       sensor.CheckStateAndReportIfNeeded(currentReadings, acceptableDeviation, controlSystemId, timeInfo, serverUrl);
77     }
78   }
79   else
80   {
81     Serial.println("controller is disabled"); 
82   }
83 
84   delay(5000);
85 }


Файл «InitUserGreenhouse.h»:
1  #include <HTTPClient.h>
2  #include <ArduinoJson.h>
3  
4  int InitUserId(String user_email_arg, String user_password_arg, int controlSystemId_arg, String serverUrl)
5  {
6    int localUserId = -1;
7    if (WiFi.status() == WL_CONNECTED) {
8      HTTPClient http;
9      
10     http.begin(serverUrl + "api/users/login");
11 
12     // Setup headers
13     http.addHeader("Content-Type", "application/json");
14     http.addHeader("ngrok-skip-browser-warning", "true");
15 
16     // Create JSON payload
17     DynamicJsonDocument jsonDocument(1024);
18     jsonDocument["email"] = user_email_arg;
19     jsonDocument["password"] = user_password_arg;
20 
21     String jsonPayload;
22     serializeJson(jsonDocument, jsonPayload);
23 
24     // Make the POST request
25     int httpResponseCode = http.POST(jsonPayload);
26 
27     Serial.printf("HTTP Response code: %d\n", httpResponseCode);
28     if (httpResponseCode >= 200 && httpResponseCode <= 400) 
29     {
30       // Parse JSON response
31       DynamicJsonDocument jsonDocumentResponse(1024); // Adjust the size according to your response
32       deserializeJson(jsonDocumentResponse, http.getString());
33 
34       //serializeJsonPretty(jsonDocumentResponse, Serial);
35 
36       // Extract user ID
37       localUserId = jsonDocumentResponse["userId"].as<int>();
38 
39       // Save the user ID or perform further actions
40       Serial.print("User ID: ");
41       Serial.println(localUserId);
42 
43       http.begin(serverUrl + "api/greenhouses");
44       httpResponseCode = http.GET();
45       Serial.printf("HTTP Response code: %d\n", httpResponseCode);
46       DynamicJsonDocument jsonDocumentResponseControl(1024); // Adjust the size according to your response
47       deserializeJson(jsonDocumentResponseControl, http.getString());
48 
49       bool belongsToUser = false;
50 
51       // Ensure that the response is an array
52       JsonArray usersArray = jsonDocumentResponseControl.as<JsonArray>();
53       // Iterate through the array and check if userId matches any user
54       for (const JsonVariant& userVariant : usersArray) {
55           if (userVariant["user"]["userId"].as<int>() == localUserId) 
56           {
57               belongsToUser = true;
58               break;
59           }
60       }
61 
62       // Close connection
63       http.end();
64 
65       if(!belongsToUser)
66       {
67         Serial.print("Wrong credentials for this system \n");
68       }
69       else
70       {
71         Serial.print("Successful authentification \n");
72       }
73     }
74     else 
75     {
76       Serial.printf("HTTP Request failed, error: %s\n", http.errorToString(httpResponseCode).c_str());
77     }  
78   }
79   return localUserId;
80 }


Файл «Sensor.h»:
1  #include <HTTPClient.h>
2  #include <ArduinoJson.h>
3  #include "Notification.h"
4  #include "Schedule.h"
5  
6  struct Sensor
7  {
8    Sensor() {}
9    Sensor(int _sensorId, int _sensorType, float _minRefValue, float _maxRefValue,
10          bool _isActive, std::vector<Schedule> _schedules)
11    {
12      sensorId = _sensorId;
13      sensorType = _sensorType;
14      minRefValue = _minRefValue;
15      maxRefValue = _maxRefValue;
16      isActive = _isActive;
17      schedules = _schedules;
18    }
19  
20    void CheckStateAndReportIfNeeded(float currentReadings, float acceptableDeviation, int controlSystemId, tm timeInfo, String serverUrl)
21    {
22      if(!isActive)
23      {
24        return;
25      }
26      bool inActiveSchedule = false;
27      bool doesScheduleExist = false;
28      for(auto& schedule : schedules)
29      {
30        doesScheduleExist = true;
31        if((timeInfo.tm_hour > schedule.startTime.tm_hour || (timeInfo.tm_hour == schedule.startTime.tm_hour && timeInfo.tm_min > schedule.startTime.tm_min)) 
32        || (timeInfo.tm_hour < schedule.endTime.tm_hour || (timeInfo.tm_hour == schedule.startTime.tm_hour && timeInfo.tm_min < schedule.startTime.tm_min)))
33        {
34          inActiveSchedule = true;
35          break;
36        }
37      }
38      if(doesScheduleExist && !inActiveSchedule)
39      {
40        Serial.println("sensor is disabled");
41        return;
42      }
43  
44      if(currentReadings - minRefValue + acceptableDeviation <= 0 || maxRefValue - currentReadings + acceptableDeviation <= 0)
45      {
46        if(abs(lastReported - currentReadings) >= acceptableDeviation)
47        {
48          lastReported = currentReadings;
49          int sensorReadingId = PostSensorReading(serverUrl, currentReadings, timeInfo, sensorId);
50          PostNotification(serverUrl, sensorReadingId, currentReadings, minRefValue, maxRefValue, sensorType);
51        }
52      }
53    }
54  
55    float lastReported = 0.0f;
56    int sensorId;
57    int sensorType;
58    float minRefValue;
59    float maxRefValue;
60    bool isActive;
61    std::vector<Schedule> schedules;
62  };


Файл «Greenhouse.h»:
1  #include <HTTPClient.h>
2  #include <ArduinoJson.h>
3  #include "Sensor.h"
4  #include <vector>
5  
6  struct Greenhouse
7  {
8    Greenhouse() {}
9    Greenhouse(int controlSystemId, String serverUrl)
10   {
11     HTTPClient http;
12     String url = serverUrl + "api/sensors/byGreenhouseId/" + String(controlSystemId);
13 
14     // Begin HTTP communication with the server
15     http.begin(url);
16 
17     // Make the POST request
18     int httpResponseCode = http.GET();
19 
20     Serial.printf("HTTP Response code: %d\n", httpResponseCode);
21     if (httpResponseCode >= 200 && httpResponseCode <= 400) 
22     {
23       DynamicJsonDocument jsonDocumentResponse(1024);
24       deserializeJson(jsonDocumentResponse, http.getString());
25 
26       //serializeJsonPretty(jsonDocumentResponse, Serial);
27 
28       JsonArray jsonArray = jsonDocumentResponse.as<JsonArray>();
29       for (const JsonVariant& jsonVariant : jsonArray) 
30       {
31           int sensorId = jsonVariant["sensorId"];
32           int sensorType = jsonVariant["sensorType"];
33           float minRefValue = jsonVariant["minValue"];
34           float maxRefValue = jsonVariant["maxValue"];
35           bool isActive = jsonVariant["isActive"];
36           std::vector<Schedule> schedules = Schedule::GetSchedules(sensorId, serverUrl);
37 
38           Sensor tempSensor = Sensor(sensorId, sensorType, minRefValue, maxRefValue,
39                                      isActive, schedules);
40           sensors.push_back(tempSensor);
41       }
42     }
43 
44     http.end();
45   }
46 
47   std::vector<Sensor> sensors;
48 };

Файл «Schedule.h»:
1  #include <HTTPClient.h>
2  #include <ArduinoJson.h>
3  
4  struct Schedule
5  {
6    static std::vector<Schedule> GetSchedules(int sensorId, String serverUrl)
7    {
8      std::vector<Schedule> schedules;
9  
10     HTTPClient http;
11     String url = serverUrl + "api/schedules/bySensorId/" + String(sensorId);
12     http.begin(url);
13 
14     int httpResponseCode = http.GET();
15 
16     Serial.printf("HTTP Response code: %d\n", httpResponseCode);
17     if (httpResponseCode >= 200 && httpResponseCode <= 400) 
18     {
19       DynamicJsonDocument jsonDocumentResponse(1024);
20       deserializeJson(jsonDocumentResponse, http.getString());
21 
22       JsonArray jsonArray = jsonDocumentResponse.as<JsonArray>();
23       for (const JsonVariant& jsonVariant : jsonArray) 
24       {
25         Schedule tempSchedule;
26         String startTimeStr = jsonVariant["startTime"];
27         String endTimeStr = jsonVariant["endTime"];
28 
29         sscanf(startTimeStr.c_str(), "%d-%d-%dT%d:%d:%fZ", &tempSchedule.startTime.tm_year, &tempSchedule.startTime.tm_mon, &tempSchedule.startTime.tm_mday,
30           &tempSchedule.startTime.tm_hour, &tempSchedule.startTime.tm_min, &tempSchedule.startTime.tm_sec);
31         sscanf(endTimeStr.c_str(), "%d-%d-%dT%d:%d:%fZ", &tempSchedule.endTime.tm_year, &tempSchedule.endTime.tm_mon, &tempSchedule.endTime.tm_mday,
32           &tempSchedule.endTime.tm_hour, &tempSchedule.endTime.tm_min, &tempSchedule.endTime.tm_sec);
33 
34         schedules.push_back(tempSchedule);
35       }
36     }
37     http.end();
38 
39     return schedules;
40   }
41 
42   tm startTime;
43   tm endTime;
44 };


Файл «Notification.h»:
1  #include <HTTPClient.h>
2  #include <ArduinoJson.h>
3  
4  static int PostSensorReading(String serverUrl, float value, tm timestamp, int sensorId)
5  {
6    char formattedTime[25];
7    strftime(formattedTime, sizeof(formattedTime), "%Y-%m-%dT%H:%M:%S.000Z", &timestamp);
8    String notificationDateTime = String(formattedTime);
9  
10   HTTPClient http;
11   http.begin(serverUrl + "api/sensorReadings");
12 
13   http.addHeader("Content-Type", "application/json");
14 
15   DynamicJsonDocument jsonDocument(1024);
16   jsonDocument["value"] = value;
17   jsonDocument["timestamp"] = formattedTime;
18   jsonDocument["sensorId"] = sensorId; 
19 
20   String jsonPayload;
21   serializeJson(jsonDocument, jsonPayload);
22 
23   int httpResponseCode = http.POST(jsonPayload);
24 
25   Serial.printf("HTTP Response code: %d\n", httpResponseCode);
26 
27   if (httpResponseCode >= 200 && httpResponseCode <= 400) 
28   {
29     DynamicJsonDocument jsonDocumentResponse(1024);
30     deserializeJson(jsonDocumentResponse, http.getString());
31 
32     return jsonDocumentResponse["sensorReadingId"].as<int>();
33   }
34   return -1;
35 }
36 
37 static void PostNotification(String serverUrl, int sensorReadingId, float value, float minRefValue, float maxRefValue, int sensorType)
38 {
39   String sensorName;
40   switch(sensorType)
41   {
42     case 0:
43     sensorName = "Temperature";
44     break;
45 
46     case 1:
47     sensorName = "Humidity";
48     break;
49 
50     case 2:
51     sensorName = "Lighting";
52     break;
53 
54     case 3:
55     sensorName = "Acidity";
56     break;
57 
58     default:
59     sensorName = "Undefined";
60     break;
61   }
62 
63   String title = "Readings diverse from configuration";
64   String notificationMessage = String("The readings of ") + sensorName + " sensor are our of range. " + "Expected value from " + minRefValue + " to " + maxRefValue + ". Currently, the value is " + value;
65 
66   HTTPClient http;
67   http.begin(serverUrl + "api/notifications");
68 
69   http.addHeader("Content-Type", "application/json");
70 
71   DynamicJsonDocument jsonDocument(1024);
72   jsonDocument["title"] = title;
73   jsonDocument["message"] = notificationMessage;
74   jsonDocument["isSent"] = true; 
75   jsonDocument["sensorReadingId"] = sensorReadingId; 
76 
77   String jsonPayload;
78   serializeJson(jsonDocument, jsonPayload);
79 
80   int httpResponseCode = http.POST(jsonPayload);
81 
82   Serial.printf("HTTP Response code: %d\n", httpResponseCode);
83 }


ДОДАТОК В
Код веб-додатку
Файл «GreenhousesPage.js»:
1  import React, { useState, useEffect } from 'react';
2  import { FormattedMessage } from 'react-intl';
3  import '../../styles/user/greenhouses.css';
4  import { useNavigate } from 'react-router-dom';
5  import { deleteGreenhouse, getGreenhouseByUserId } from '../../services/GreenhouseService';
6  
7  const GreenhousesPage = () => {
8      const [greenhouses, setGreenhouses] = useState([]);
9      const [isLoading, setIsLoading] = useState(true);
10     const [error, setError] = useState(null);
11     const navigate = useNavigate();
12 
13     const userData = localStorage.getItem('user');
14     const user = userData ? JSON.parse(userData) : null;
15 
16     useEffect(() => {
17         const fetchGreenhouses = async () => {
18             try {
19                 const greenhouses = await getGreenhouseByUserId(user.userId);
20                 setGreenhouses(greenhouses);
21                 console.log(greenhouses);
22                 if (greenhouses.length === 0) {
23                     setError("No greenhouses found.");
24                 } else {
25                     setError(null);
26                 }
27             } catch (error) {
28                 console.error('Error fetching greenhouses:', error);
29                 setError('Failed to fetch greenhouses');
30             } finally {
31                 setIsLoading(false);
32             }
33         };
34 
35         if (user && user.userId) {
36             fetchGreenhouses();
37         } else {
38             setIsLoading(false);
39             setError("User not found.");
40         }
41     }, [user?.userId]);
42 
43     const handleAddGreenhouse = () => {
44         navigate('/user/addGreenhouse');
45     };
46 
47     const handleEditGreenhouse = (greenhouseId) => {
48         navigate(`/user/editGreenhouse/${greenhouseId}`);
49     };
50 
51     const handleDeleteGreenhouse = async (greenhouseId) => {
52         try {
53             await deleteGreenhouse(greenhouseId);
54             setGreenhouses(greenhouses.filter((greenhouse) => greenhouse.greenhouseId !== greenhouseId));
55         } catch (error) {
56             console.error('Error deleting greenhouse:', error);
57             setError('Failed to delete greenhouse');
58         }
59     };
60 
61     const handleViewSensors = (greenhouseId) => {
62         localStorage.setItem('greenhouseId', greenhouseId);
63         navigate(`/user/sensors/${greenhouseId}`);
64     };
65 
66     return (
67         <main className="main py-5">
68             <div className="container">
69                 <div className="row">
70                     <div className="col">
71                         <h1 className="page-title">
72                             <FormattedMessage id="greenhousesPage.title" defaultMessage="Greenhouses" />
73                         </h1>
74                     </div>
75                 </div>
76 
77                 <div className="row mb-3">
78                     <div className="col text-end">
79                         <button onClick={handleAddGreenhouse} className="btn btn-primary btn-add">
80                         <FormattedMessage id="greenhousesPage.AddGreenhouse" defaultMessage="Add Greenhouse" />
81                         </button>
82                     </div>
83                 </div>
84 
85                 <div className="row">
86                     <div className="col">
87                         {isLoading ? (
88                             <p>Loading greenhouses...</p>
89                         ) : greenhouses && greenhouses.length > 0 ? (
90                             <ul className="list-group">
91                                 {greenhouses.map(greenhouse => (
92                                     <li key={greenhouse.greenhouseId} className="list-group-item greenhouse-item">
93                                         {greenhouse.name}
94                                         <div className="button-group">
95                                             <button
96                                                 onClick={() => handleEditGreenhouse(greenhouse.greenhouseId)}
97                                                 className="btn btn-sm btn-edit"
98                                             >
99                                                 <FormattedMessage id="greenhousesPage.Edit" defaultMessage="Edit" />
100                                            </button>
101                                            <button
102                                                onClick={() => handleDeleteGreenhouse(greenhouse.greenhouseId)}
103                                                className="btn btn-sm btn-delete"
104                                            >
105                                                <FormattedMessage id="greenhousesPage.Delete" defaultMessage="Delete" />
106                                            </button>
107                                            <button
108                                                onClick={() => handleViewSensors(greenhouse.greenhouseId)}
109                                                className="btn btn-sm btn-view"
110                                            >
111                                                <FormattedMessage id="greenhousesPage.Viewsensors" defaultMessage="View sensors" />
112                                            </button>
113                                        </div>
114                                    </li>
115                                ))}
116                            </ul>
117                        ) : (
118                            <p className="text-muted"><FormattedMessage id="greenhousesPage.No" defaultMessage="No greenhouses found. Create one to get started." /></p>
119                        )}
120                    </div>
121                </div>
122            </div>
123        </main>
124    );
125 };
126 
127 export default GreenhousesPage;


Файл «SensorsPage.js»:
1  import React, { useEffect, useState } from 'react';
2  import { useParams } from 'react-router-dom';
3  import { getSensorsByGreenhouseId, deleteSensor } from '../../services/SensorService';
4  import { useNavigate } from 'react-router-dom';
5  import { FormattedMessage } from 'react-intl';
6  import '../../styles/user/sensors.css';
7
8  const sensorTypesEnum = {
9      Temperature: 'Temperature',
10     Humidity: 'Humidity',
11     Lighting: 'Lighting',
12     Acidity: 'Acidity'
13 };
14
15 const sensorTypesArray = [
16     sensorTypesEnum.Temperature,
17     sensorTypesEnum.Humidity,
18     sensorTypesEnum.Lighting,
19     sensorTypesEnum.Acidity
20 ];  
21
22 const SensorsPage = () => {
23     const { greenhouseId } = useParams();
24     const [sensors, setSensors] = useState([]);
25     const [loading, setLoading] = useState(false);
26     const [error, setError] = useState(null);
27     const [sortConfig, setSortConfig] = useState({ key: 'sensorId', direction: 'ascending' });
28     const navigate = useNavigate();
29
30     const userData = localStorage.getItem('user');
31     const user = userData ? JSON.parse(userData) : null;
32
33     const fetchSensors = async () => {
34         if (!user || !user.userId) {
35             setError('User not found.');
36             setLoading(false);
37             return;
38         }
39
40         try {
41             setLoading(true);
42             let data;
43             console.log('Fetching sensors for greenhouseId:', greenhouseId);
44             data = await getSensorsByGreenhouseId(greenhouseId);
45             if (Array.isArray(data)) {
46                 setSensors(data);
47                 console.log('Valid data format');
48             } else {
49                 console.log('Invalid data format');
50             }
51         } catch (error) {
52             console.error('Error fetching sensors:', error);
53             setError('Failed to fetch sensors. Please try again.');
54         } finally {
55             setLoading(false);
56         }
57     };
58
59     useEffect(() => {
60         fetchSensors();
61     }, [greenhouseId]);
62
63     const handleAddSensor = () => {
64         navigate('/user/addSensor');
65     };
66
67     const handleEditSensor = (sensorId) => {
68         navigate(`/user/editSensor/${sensorId}`);
69     };
70
71     const handleDeleteSensor = async (sensorId) => {
72         try {
73             await deleteSensor(sensorId);
74             let data;
75             data = await getSensorsByGreenhouseId(greenhouseId);
76             setSensors(data);
77         } catch (error) {
78             console.error('Error deleting sensor:', error);
79             setError('Failed to delete sensor');
80         }
81     };
82
83     const handleViewSchedules = (sensorId, sensorType) => {
84         localStorage.setItem('sensorId', sensorId);
85         localStorage.setItem('sensorType', sensorType);
86         navigate(`/user/schedules/${sensorId}`);
87     };
88
89     const sortedSensors = [...sensors].sort((a, b) => {
90         if (a[sortConfig.key] < b[sortConfig.key]) {
91             return sortConfig.direction === 'ascending' ? -1 : 1;
92         }
93         if (a[sortConfig.key] > b[sortConfig.key]) {
94             return sortConfig.direction === 'ascending' ? 1 : -1;
95         }
96         return 0;
97     });
98
99     const requestSort = (key) => {
100        let direction = 'ascending';
101        if (
102            sortConfig.key === key &&
103            sortConfig.direction === 'ascending'
104        ) {
105            direction = 'descending';
106        }
107        setSortConfig({ key, direction });
108    };
109
110    if (loading) {
111        return <div>Loading...</div>;
112    }
113
114    if (error) {
115        return <div>Error: {error}</div>;
116    }
117
118    return (
119        <main className="main py-5">
120            <div className="container">
121                <div className="row">
122                    <div className="col">
123                        <h1 className="page-title">
124                            <FormattedMessage id="sensorsPage.title" defaultMessage="Sensors" />
125                        </h1>
126                    </div>
127                </div>
128                <div className="row">
129                    <div className="col">
130                        <h1 className="page-description">
131                            <FormattedMessage id="sensorsPage.description" defaultMessage="Greenhouse ID: " />
132                            {greenhouseId}
133                        </h1>
134                    </div>
135                </div>
136                <div className="row mb-3">
137                    <div className="col text-end">
138                        <button onClick={handleAddSensor} className="btn btn-primary btn-add-sensor">
139                        <FormattedMessage id="sensorsPage.AddSensor" defaultMessage="Add Sensor" />
140                        </button>
141                    </div>
142                </div>
143
144                {sensors.length === 0 ? (
145                    <div><FormattedMessage id="sensorsPage.No" defaultMessage="No sensors found." /></div>
146                ) : (
147                    <table className="table-sensors">
148                        <thead>
149                            <tr>
150                                <th onClick={() => requestSort('sensorId')}><FormattedMessage id="sensorsPage.SensorID" defaultMessage="Sensor ID" /></th>
151                                <th><FormattedMessage id="sensorsPage.SensorType" defaultMessage="Sensor Type" /></th>
152                                <th onClick={() => requestSort('minValue')}><FormattedMessage id="sensorsPage.MinValue" defaultMessage="Min Value" /></th>
153                                <th onClick={() => requestSort('maxValue')}><FormattedMessage id="sensorsPage.MaxValue" defaultMessage="Max Value" /></th>
154                                <th><FormattedMessage id="sensorsPage.Is Active" defaultMessage="IsActive" /></th>
155                                <th><FormattedMessage id="sensorsPage.Actions" defaultMessage="Actions" /></th>
156                            </tr>
157                        </thead>
158                        <tbody>
159                            {sortedSensors.map(sensor => (
160                                <tr key={sensor.sensorId}>
161                                    <td>{sensor.sensorId}</td>
162                                    <td>{sensorTypesArray[sensor.sensorType]}</td>
163                                    <td>{sensor.minValue}</td>
164                                    <td>{sensor.maxValue}</td>
165                                    <td>{sensor.isActive ? 'Yes' : 'No'}</td>
166                                    <td>
167                                        <div className="button-group-sensors">
168                                            <button
169                                                onClick={() => handleEditSensor(sensor.sensorId)}
170                                                className="btn btn-sm btn-edit-sensor"
171                                            >
172                                                <FormattedMessage id="sensorsPage.Edit" defaultMessage="Edit" />
173                                            </button>
174                                            <button
175                                                onClick={() => handleDeleteSensor(sensor.sensorId)}
176                                                className="btn btn-sm btn-delete-sensor"
177                                            >
178                                                <FormattedMessage id="sensorsPage.Delete" defaultMessage="Delete" />
179                                            </button>
180                                            <button
181                                                onClick={() => handleViewSchedules(sensor.sensorId, sensor.sensorType)}
182                                                className="btn btn-sm btn-view-schedules"
183                                            >
184                                                <FormattedMessage id="sensorsPage.Viewschedules" defaultMessage="View schedules" />
185                                            </button>
186                                        </div>
187                                    </td>
188                                </tr>
189                            ))}
190                        </tbody>
191                    </table>
192                )}
193            </div>
194        </main>
195    );
196 };
197
198 export default SensorsPage;


Файл «SchedulesPage.js»:
1  import React, { useEffect, useState } from 'react';
2  import { useParams, useNavigate } from 'react-router-dom';
3  import { getSchedulesBySensorId, deleteSchedule } from '../../services/ScheduleService';
4  import { FormattedMessage } from 'react-intl';
5  import '../../styles/user/schedules.css';
6
7  const sensorTypesEnum = {
8      Temperature: 'Temperature',
9      Humidity: 'Humidity',
10     Lighting: 'Lighting',
11     Acidity: 'Acidity'
12 };
13
14 const sensorTypesArray = [
15     sensorTypesEnum.Temperature,
16     sensorTypesEnum.Humidity,
17     sensorTypesEnum.Lighting,
18     sensorTypesEnum.Acidity
19 ];
20
21 const SchedulesPage = () => {
22     const { sensorId } = useParams();
23     const [schedules, setSchedules] = useState([]);
24     const [loading, setLoading] = useState(false);
25     const [error, setError] = useState(null);
26     const [sortConfig, setSortConfig] = useState({ key: 'scheduleId', direction: 'ascending' });
27     const navigate = useNavigate();
28
29     const fetchSchedules = async () => {
30         try {
31             setLoading(true);
32             const data = await getSchedulesBySensorId(sensorId);
33             setSchedules(data);
34         } catch (error) {
35             console.error('Error fetching schedules:', error);
36             setError('Failed to fetch schedules. Please try again.');
37         } finally {
38             setLoading(false);
39         }
40     };
41
42     useEffect(() => {
43         fetchSchedules();
44     }, [sensorId]);
45
46     const handleAddSchedule = () => {
47         navigate(`/user/addSchedule/${sensorId}`);
48     };
49
50     const handleEditSchedule = (scheduleId) => {
51         localStorage.setItem('sensorId', sensorId);
52         navigate(`/user/editSchedule/${scheduleId}`);
53     };
54
55     const handleDeleteSchedule = async (scheduleId) => {
56         try {
57             await deleteSchedule(scheduleId);
58             const data = await getSchedulesBySensorId(sensorId);
59             setSchedules(data);
60         } catch (error) {
61             console.error('Error deleting schedule:', error);
62             setError('Failed to delete schedule');
63         }
64     };
65
66     const sortedSchedules = [...schedules].sort((a, b) => {
67         if (a[sortConfig.key] < b[sortConfig.key]) {
68             return sortConfig.direction === 'ascending' ? -1 : 1;
69         }
70         if (a[sortConfig.key] > b[sortConfig.key]) {
71             return sortConfig.direction === 'ascending' ? 1 : -1;
72         }
73         return 0;
74     });
75
76     const requestSort = (key) => {
77         let direction = 'ascending';
78         if (
79             sortConfig.key === key &&
80             sortConfig.direction === 'ascending'
81         ) {
82             direction = 'descending';
83         }
84         setSortConfig({ key, direction });
85     };
86
87     if (loading) {
88         return <div>Loading...</div>;
89     }
90
91     if (error) {
92         return <div>Error: {error}</div>;
93     }
94
95     return (
96         <main className="main py-5">
97             <div className="container">
98                 <div className="row">
99                     <div className="col">
100                        <h1 className="page-title">
101                            <FormattedMessage id="schedulesPage.title" defaultMessage="Schedules" />
102                        </h1>
103                    </div>
104                </div>
105                <div className="row">
106                    <div className="col">
107                        <h1 className="page-description">
108                            <FormattedMessage id="schedulesPage.description" defaultMessage="Sensor ID: " />
109                            {sensorId}
110                        </h1>
111                    </div>
112                </div>
113                <div className="row mb-3">
114                    <div className="col text-end">
115                        <button onClick={handleAddSchedule} className="btn btn-primary btn-add-schedule">
116                        <FormattedMessage id="schedulesPage.AddSchedule" defaultMessage="Add Schedule" />
117                        </button>
118                    </div>
119                </div>
120
121                {schedules.length === 0 ? (
122                    <div><FormattedMessage id="schedulesPage.No" defaultMessage="No schedules found." /></div>
123                ) : (
124                    <table className="table-schedules">
125                        <thead>
126                            <tr>
127                                <th onClick={() => requestSort('scheduleId')}><FormattedMessage id="schedulesPage.ScheduleID" defaultMessage="Schedule ID" /></th>
128                                <th onClick={() => requestSort('startTime')}><FormattedMessage id="schedulesPage.StartTime" defaultMessage="Start Time" /></th>
129                                <th onClick={() => requestSort('endTime')}><FormattedMessage id="schedulesPage.EndTime" defaultMessage="End Time" /></th>
130                                <th><FormattedMessage id="schedulesPage.Actions" defaultMessage="Actions" /></th>
131                            </tr>
132                        </thead>
133                        <tbody>
134                            {sortedSchedules.map(schedule => (
135                                <tr key={schedule.scheduleId}>
136                                    <td>{schedule.scheduleId}</td>
137                                    <td>{new Date(schedule.startTime).toISOString().replace('T', ' ').substr(0, 19)}</td>
138                                    <td>{new Date(schedule.endTime).toISOString().replace('T', ' ').substr(0, 19)}</td>
139                                    <td>
140                                        <div className="button-group-schedules">
141                                            <button
142                                                onClick={() => handleEditSchedule(schedule.scheduleId)}
143                                                className="btn btn-sm btn-edit-schedule"
144                                            >
145                                                <FormattedMessage id="schedulesPage.Edit" defaultMessage="Edit" />
146                                            </button>
147                                            <button
148                                                onClick={() => handleDeleteSchedule(schedule.scheduleId)}
149                                                className="btn btn-sm btn-delete-schedule"
150                                            >
151                                                <FormattedMessage id="schedulesPage.Delete" defaultMessage="Delete" />
152                                            </button>
153                                        </div>
154                                    </td>
155                                </tr>
156                            ))}
157                        </tbody>
158                    </table>
159                )}
160            </div>
161        </main>
162    );
163 };
164
165 export default SchedulesPage;


Файл «AddSensorPage.js»:
1  import React, { useState, useEffect } from 'react';
2  import { useNavigate } from 'react-router-dom';
3  import { FormattedMessage } from 'react-intl';
4  import { addSensor } from '../../services/SensorService';
5  import { getGreenhouseByUserId } from '../../services/GreenhouseService';
6  import '../../styles/user/addSensor.css';
7
8  const sensorTypesEnum = {
9    0: 'Temperature',
10   1: 'Humidity',
11   2: 'Lighting',
12   3: 'Acidity'
13 };
14
15 const sensorTypesEnumReverse = {
16   'Temperature': 0,
17   'Humidity': 1,
18   'Lighting': 2,
19   'Acidity': 3
20 };
21
22 const AddSensorPage = ({ userId, onSuccess }) => {
23   const [sensorType, setSensorType] = useState('');
24   const [minValue, setMinValue] = useState('');
25   const [maxValue, setMaxValue] = useState('');
26   const [isActive, setIsActive] = useState(false);
27   const [isLoading, setIsLoading] = useState(false);
28   const [greenhouses, setGreenhouses] = useState({});
29   const [selectedGreenhouseId, setSelectedGreenhouseId] = useState('');
30   const [error, setError] = useState(null);
31
32   let greenhouseId = localStorage.getItem('greenhouseId');
33
34   const navigate = useNavigate();
35
36   if (!userId) {
37     const userData = localStorage.getItem('user');
38     const user = userData ? JSON.parse(userData) : null;
39     userId = user.userId;
40   }
41
42   useEffect(() => {
43     const fetchGreenhouses = async () => {
44       try {
45         const data = await getGreenhouseByUserId(userId);
46         let greenhouseOptions = {};
47         data.forEach(greenhouse => {
48           greenhouseOptions[greenhouse.greenhouseId] = greenhouse.name;
49         });
50         setGreenhouses(greenhouseOptions);
51         const keys = Object.keys(greenhouseOptions);
52         console.log("Keys:", keys);
53       } catch (error) {
54         console.error('Error fetching greenhouses:', error);
55         setError('Failed to load greenhouses. Please try again later.');
56       }
57     };
58     fetchGreenhouses();
59   }, [userId]);
60
61   const handleAddSensor = async (event) => {
62     event.preventDefault();
63
64     const numericSensorType = sensorTypesEnumReverse[sensorType];
65
66     const sensorData = {
67       sensorType: numericSensorType,
68       minValue: parseFloat(minValue),
69       maxValue: parseFloat(maxValue),
70       isActive,
71       greenhouseId: greenhouseId
72     };
73
74     console.log(sensorData);
75
76     try {
77       setIsLoading(true);
78       await addSensor(sensorData);
79       setIsLoading(false);
80       alert('Sensor created successfully');
81       navigate(`/user/sensors/${greenhouseId}`);
82
83     } catch (error) {
84       setIsLoading(false);
85       console.error('Error adding sensor:', error);
86       setError(error.response?.data?.message || 'Failed to add sensor. Please try again.');
87     }
88   };
89
90   return (
91     <main className="add-sensor-page main py-5">
92       <div className="container">
93         <div className="row">
94           <div className="col">
95             <h1 className="page-title">
96               <FormattedMessage id="addSensorPage.title" defaultMessage="Add Sensor" />
97             </h1>
98           </div>
99         </div>
100        {error && <div className="alert alert-danger" role="alert">{error}</div>}
101        <div className="row form-container">
102          <div className="col-md-6">
103            <form onSubmit={handleAddSensor}>
104              <div className="mb-3">
105                <label htmlFor="sensorType" className="form-label"><FormattedMessage id="addSensorPage.SensorType" defaultMessage="Sensor Type:" /></label>
106                <select
107                  className="form-control"
108                  id="sensorType"
109                  value={sensorType}
110                  onChange={(e) => setSensorType(e.target.value)}
111                  required
112                >
113                  <option value="" disabled>Select a sensor type</option>
114                  {Object.keys(sensorTypesEnum).map((key) => (
115                    <option key={key} value={sensorTypesEnum[key]}>
116                      {sensorTypesEnum[key]}
117                    </option>
118                  ))}
119                </select>
120              </div>
121
122              <div className="mb-3">
123                <label htmlFor="minValue" className="form-label"><FormattedMessage id="addSensorPage.MinValue" defaultMessage="Min Value:" /></label>
124                <input
125                  type="number"
126                  className="form-control"
127                  id="minValue"
128                  value={minValue}
129                  onChange={(e) => setMinValue(e.target.value)}
130                  required
131                />
132              </div>
133              <div className="mb-3">
134                <label htmlFor="maxValue" className="form-label"><FormattedMessage id="addSensorPage.MaxValue" defaultMessage="Max Value:" /></label>
135                <input
136                  type="number"
137                  className="form-control"
138                  id="maxValue"
139                  value={maxValue}
140                  onChange={(e) => setMaxValue(e.target.value)}
141                  required
142                />
143              </div>
144              <div className="mb-3 form-check">
145                <input
146                  type="checkbox"
147                  className="form-check-input"
148                  id="isActive"
149                  checked={isActive}
150                  onChange={(e) => setIsActive(e.target.checked)}
151                />
152                <label className="form-check-label" htmlFor="isActive"><FormattedMessage id="addSensorPage.IsActive" defaultMessage="Is Active" /></label>
153              </div>
154
155              <button type="submit" className="btn btn-submit" disabled={isLoading}>
156                {isLoading ? <span className="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> : 'Add Sensor'}
157              </button>
158            </form>
159          </div>
160        </div>
161      </div>
162    </main>
163  );
164 };
165
166 export default AddSensorPage;


Файл «EditSensorPage.js»:
1  import React, { useState, useEffect } from 'react';
2  import { useNavigate, useParams } from 'react-router-dom';
3  import { FormattedMessage } from 'react-intl';
4  import { getSensorById, updateSensor } from '../../services/SensorService';
5  import { getGreenhouseByUserId } from '../../services/GreenhouseService';
6  import '../../styles/user/editSensor.css';
7
8  const sensorTypesEnum = {
9    0: 'Temperature',
10   1: 'Humidity',
11   2: 'Lighting',
12   3: 'Acidity'
13 };
14
15 const sensorTypesEnumReverse = {
16   'Temperature': 0,
17   'Humidity': 1,
18   'Lighting': 2,
19   'Acidity': 3
20 };
21
22 const EditSensorPage = () => {
23   const { sensorId } = useParams();
24   const navigate = useNavigate();
25   const [sensorType, setSensorType] = useState('');
26   const [minValue, setMinValue] = useState('');
27   const [maxValue, setMaxValue] = useState('');
28   const [isActive, setIsActive] = useState(false);
29   const [isLoading, setIsLoading] = useState(false);
30   const [greenhouses, setGreenhouses] = useState({});
31   const [selectedGreenhouseId, setSelectedGreenhouseId] = useState('');
32   const [error, setError] = useState(null);
33
34   const userData = localStorage.getItem('user');
35   const user = userData ? JSON.parse(userData) : null;
36   const userId = user.userId;
37
38   useEffect(() => {
39     const fetchGreenhouses = async () => {
40       try {
41         const data = await getGreenhouseByUserId(userId);
42         let greenhouseOptions = {};
43         data.forEach(greenhouse => {
44           greenhouseOptions[greenhouse.greenhouseId] = greenhouse.name;
45         });
46         setGreenhouses(greenhouseOptions);
47         const keys = Object.keys(greenhouseOptions);
48         console.log("Keys:", keys);
49
50         const sensor = await getSensorById(sensorId);
51         setSensorType(sensorTypesEnum[sensor.sensorType]);
52         setMinValue(sensor.minValue);
53         setMaxValue(sensor.maxValue);
54         setIsActive(sensor.isActive);
55
56       } catch (error) {
57         console.error('Error fetching greenhouses:', error);
58         setError('Failed to load greenhouses. Please try again later.');
59       }
60     };
61     fetchGreenhouses();
62   }, [userId]);
63
64   const handleEditSensor = async (event) => {
65     event.preventDefault();
66
67     const numericSensorType = sensorTypesEnumReverse[sensorType];
68     let greenhouseId = localStorage.getItem('greenhouseId');
69
70     const sensorData = {
71       sensorType: numericSensorType,
72       minValue: parseFloat(minValue),
73       maxValue: parseFloat(maxValue),
74       isActive,
75       greenhouseId: greenhouseId
76     };
77
78     console.log(sensorData);
79
80     try {
81       setIsLoading(true);
82       await updateSensor(sensorId, sensorData);
83       alert('Sensor updated successfully');
84       navigate(`/user/sensors/${greenhouseId}`);
85
86     } catch (error) {
87       console.error('Error updating sensor:', error);
88       setError(error.response?.data?.message || 'Failed to update sensor');
89     } finally {
90       setIsLoading(false);
91     }
92   };
93
94   return (
95     <main className="edit-sensor-page main py-5">
96       <div className="container">
97         <div className="row">
98           <div className="col">
99             <h1 className="page-title">
100               <FormattedMessage id="editSensorPage.title" defaultMessage="Edit Sensor" />
101             </h1>
102           </div>
103         </div>
104
105         <div className="row form-container">
106           <div className="col-md-6">
107             {error ? (
108               <div className="alert alert-danger">{error}</div>
109             ) : isLoading ? (
110               <p>Loading sensor data...</p>
111             ) : (
112               <form onSubmit={handleEditSensor}>
113                 <div className="mb-3">
114                   <label htmlFor="sensorType" className="form-label"><FormattedMessage id="editSensorPage.SensorType" defaultMessage="Sensor Type:" /></label>
115                   <select
116                     className="form-control"
117                     id="sensorType"
118                     value={sensorType}
119                     onChange={(e) => setSensorType(e.target.value)}
120                     required
121                   >
122                     <option value="" disabled>Select a sensor type</option>
123                     {Object.keys(sensorTypesEnum).map((key) => (
124                       <option key={key} value={sensorTypesEnum[key]}>
125                         {sensorTypesEnum[key]}
126                       </option>
127                     ))}
128                   </select>
129                 </div>
130                 <div className="mb-3">
131                   <label htmlFor="minValue" className="form-label"><FormattedMessage id="editSensorPage.MinValue" defaultMessage="Min Value:" /></label>
132                   <input
133                     type="number"
134                     className="form-control"
135                     id="minValue"
136                     value={minValue}
137                     onChange={(e) => setMinValue(e.target.value)}
138                     required
139                   />
140                 </div>
141                 <div className="mb-3">
142                   <label htmlFor="maxValue" className="form-label"><FormattedMessage id="editSensorPage.MaxValue" defaultMessage="Max Value:" /></label>
143                   <input
144                     type="number"
145                     className="form-control"
146                     id="maxValue"
147                     value={maxValue}
148                     onChange={(e) => setMaxValue(e.target.value)}
149                     required
150                   />
151                 </div>
152
153                 <div className="mb-3 form-check">
154                   <input
155                     type="checkbox"
156                     className="form-check-input"
157                     id="isActive"
158                     checked={isActive}
159                     onChange={(e) => setIsActive(e.target.checked)}
160                   />
161                   <label className="form-check-label" htmlFor="isActive"><FormattedMessage id="editSensorPage.IsActive" defaultMessage="Is Active" /></label>
162                 </div>
163
164                 <button type="submit" className="btn btn-submit" disabled={isLoading}>
165                   {isLoading ? <span className="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> : 'Save Changes'}
166                 </button>
167               </form>
168             )}
169           </div>
170         </div>
171       </div>
172     </main>
173   );
174 };
175
176 export default EditSensorPage;


Файл «AddSchedulePage.js»:
1  import React, { useState, useEffect } from 'react';
2  import { useParams, useNavigate } from 'react-router-dom';
3  import { FormattedMessage } from 'react-intl';
4  import { addSchedule } from '../../services/ScheduleService';
5  import { getSensorsByUserId } from '../../services/SensorService';
6  import { format } from 'date-fns';
7  import '../../styles/user/addSchedule.css';
8
9  const AddSchedulePage = () => {
10   const { sensorId } = useParams();
11   const [startTime, setStartTime] = useState('');
12   const [endTime, setEndTime] = useState('');
13   const [sensors, setSensors] = useState([]);
14   const [isLoading, setIsLoading] = useState(false);
15   const navigate = useNavigate();
16
17   useEffect(() => {
18     const fetchSensors = async () => {
19       const userData = localStorage.getItem('user');
20       const user = userData ? JSON.parse(userData) : null;
21
22       if (!user) {
23         alert("User not found. Please log in.");
24         return;
25       }
26
27       try {
28         const data = await getSensorsByUserId(user.userId);
29         setSensors(data);
30       } catch (error) {
31         console.error('Error fetching sensors:', error);
32         alert('Failed to load sensors. Please try again later.');
33       }
34     };
35
36     fetchSensors();
37   }, []);
38
39   const handleAddSchedule = async (event) => {
40     event.preventDefault();
41
42     const startTimeUTC = format(new Date(startTime), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
43     const endTimeUTC = format(new Date(endTime), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
44
45     const scheduleData = {
46       startTime: startTimeUTC,
47       endTime: endTimeUTC,
48       sensorId: parseInt(sensorId, 10),
49     };
50
51     try {
52       setIsLoading(true);
53       await addSchedule(scheduleData);
54       setIsLoading(false);
55
56       alert('Schedule created successfully');
57       navigate(`/user/schedules/${sensorId}`);
58       
59     } catch (error) {
60       setIsLoading(false);
61       console.error('Error creating schedule:', error);
62
63       if (error.response && error.response.data) {
64         alert(error.response.data.message || 'Failed to create schedule');
65       } else {
66         alert('An unexpected error occurred. Please try again.');
67       }
68     }
69   };
70
71   return (
72     <main className="add-schedule-page main py-5">
73       <div className="container">
74         <div className="row">
75           <div className="col">
76             <h1 className="page-title">
77               <FormattedMessage id="addSchedulePage.title" defaultMessage="Add Schedule" />
78             </h1>
79           </div>
80         </div>
81         <div className="row form-container">
82           <div className="col-md-6">
83             <form onSubmit={handleAddSchedule}>
84               <div className="mb-3">
85                 <label htmlFor="startTime" className="form-label"><FormattedMessage id="addSchedulePage.StartTime" defaultMessage="Start Time:" /></label>
86                 <input
87                   type="datetime-local"
88                   className="form-control"
89                   id="startTime"
90                   value={startTime}
91                   onChange={(e) => setStartTime(e.target.value)}
92                   required
93                 />
94               </div>
95
96               <div className="mb-3">
97                 <label htmlFor="endTime" className="form-label"><FormattedMessage id="addSchedulePage.EndTime" defaultMessage="End Time:" /></label>
98                 <input
99                   type="datetime-local"
100                  className="form-control"
101                  id="endTime"
102                  value={endTime}
103                  onChange={(e) => setEndTime(e.target.value)}
104                  required
105                />
106              </div>
107              <button type="submit" className="btn btn-submit" disabled={isLoading}>
108                {isLoading ? <span className="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> : 'Add Schedule'}
109              </button>
110            </form>
111          </div>
112        </div>
113      </div>
114    </main>
115  );
116};
117
118 export default AddSchedulePage;


Файл «EditSchedulePage.js»:
1  import React, { useState, useEffect } from 'react';
2  import { useParams, useNavigate } from 'react-router-dom';
3  import { FormattedMessage } from 'react-intl';
4  import { getScheduleById, updateSchedule } from '../../services/ScheduleService';
5  import { format } from 'date-fns';
6  import '../../styles/user/editSchedule.css';
7
8  const sensorTypesEnum = {
9      Temperature: 'Temperature',
10     Humidity: 'Humidity',
11     Lighting: 'Lighting',
12     Acidity: 'Acidity'
13 };
14
15 const sensorTypesArray = [
16     sensorTypesEnum.Temperature,
17     sensorTypesEnum.Humidity,
18     sensorTypesEnum.Lighting,
19     sensorTypesEnum.Acidity
20 ];
21
22 const EditSchedulePage = () => {
23     const { scheduleId } = useParams();
24     const navigate = useNavigate();
25     const [startTime, setStartTime] = useState('');
26     const [endTime, setEndTime] = useState('');
27     const [isLoading, setIsLoading] = useState(false);
28     const [error, setError] = useState(null);
29
30     useEffect(() => {
31         const fetchSchedule = async () => {
32             try {
33                 const schedule = await getScheduleById(scheduleId);
34
35                 setStartTime(schedule.startTime);
36                 setEndTime(schedule.endTime);
37             } catch (error) {
38                 console.error('Error fetching schedule:', error);
39                 setError('Failed to load schedule. Please try again later.');
40             }
41         };
42
43         fetchSchedule();
44     }, [scheduleId]);
45
46     const handleEditSchedule = async (event) => {
47         event.preventDefault();
48
49         const startTimeUTC = format(new Date(startTime), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
50         const endTimeUTC = format(new Date(endTime), "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
51
52         const scheduleData = {
53             startTime: startTimeUTC,
54             endTime: endTimeUTC,
55         };
56
57         console.log(scheduleData);
58
59         try {
60             setIsLoading(true);
61             await updateSchedule(scheduleId, scheduleData);
62             setIsLoading(false);
63
64             alert('Schedule updated successfully');
65
66             let sensorId = localStorage.getItem('sensorId');
67             navigate(`/user/schedules/${sensorId}`);
68         } catch (error) {
69             setIsLoading(false);
70             console.error('Error updating schedule:', error);
71             setError(error.response?.data?.message || 'Failed to update schedule');
72         }
73     };
74
75     return (
76         <main className="edit-schedule-page main py-5">
77             <div className="container">
78                 <div className="row">
79                     <div className="col">
80                         <h1 className="page-title">
81                             <FormattedMessage id="editSchedulePage.title" defaultMessage="Edit Schedule" />
82                         </h1>
83                     </div>
84                 </div>
85
86                 <div className="row form-container">
87                     <div className="col-md-6">
88                         {error ? (
89                             <div className="alert alert-danger">{error}</div>
90                         ) : isLoading ? (
91                             <p>Loading schedule data...</p>
92                         ) : (
93                             <form onSubmit={handleEditSchedule}>
94                                 <div className="mb-3">
95                                     <label htmlFor="startTime" className="form-label"><FormattedMessage id="editSchedulePage.StartTime" defaultMessage="Start Time:" /></label>
96                                     <input
97                                         type="datetime-local"
98                                         className="form-control"
99                                         id="startTime"
100                                        value={startTime}
101                                        onChange={(e) => setStartTime(e.target.value)}
102                                        required
103                                    />
104                                </div>
105
106                                <div className="mb-3">
107                                    <label htmlFor="endTime" className="form-label"><FormattedMessage id="editSchedulePage.EndTime" defaultMessage="End Time:" /></label>
108                                    <input
109                                        type="datetime-local"
110                                        className="form-control"
111                                        id="endTime"
112                                        value={endTime}
113                                        onChange={(e) => setEndTime(e.target.value)}
114                                        required
115                                    />
116                                </div>
117
118                                <button type="submit" className="btn btn-submit" disabled={isLoading}>
119                                    {isLoading ? <span className="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> : 'Save Changes'}
120                                </button>
121                            </form>
122                        )}
123                    </div>
124                </div>
125            </div>
126        </main>
127    );
128 };
129
130 export default EditSchedulePage;
